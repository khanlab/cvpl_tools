<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Setting Up the Script &mdash; cvpl_tools 0.6.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=09aae1b8"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Segmentation Pipeline" href="segmentation_pipeline.html" />
    <link rel="prev" title="OME_ZARR" href="ome_zarr.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            cvpl_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="ome_zarr.html">Viewing and IO of OME Zarr</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Setting Up the Script</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dask-cluster-and-temporary-directory">Dask Cluster and temporary directory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dask-logging-setup">Dask Logging Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cachedirectory">CacheDirectory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="segmentation_pipeline.html">Defining Segmentation Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="result_caching.html">Result Caching</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../API/napari_zarr.html">cvpl_tools.ome_zarr.napari.zarr_viewer.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API/ome_zarr_io.html">cvpl_tools.ome_zarr.io.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API/imfs.html">cvpl_tools.im.fs.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API/ndblock.html">cvpl_tools.im.ndblock.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API/seg_process.html">cvpl_tools.im.seg_process.py</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">cvpl_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Setting Up the Script</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/GettingStarted/setting_up_the_script.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="setting-up-the-script">
<span id="id1"></span><h1>Setting Up the Script<a class="headerlink" href="#setting-up-the-script" title="Permalink to this heading"></a></h1>
<p>Writing code using cvpl_tools requires some setup code that configures the dask library and other
utilities we need for our image processing pipeline. Below gives a brief description for the setup of these
utilities and how they can be used when we are writing our image processing pipelines with
<code class="code docutils literal notranslate"><span class="pre">cvpl_tools.im.seg_process.SegProcess</span></code> class.</p>
<section id="dask-cluster-and-temporary-directory">
<h2>Dask Cluster and temporary directory<a class="headerlink" href="#dask-cluster-and-temporary-directory" title="Permalink to this heading"></a></h2>
<p>Dask is a multithreaded and distributed computing library, in which temporary results may not fit in
memory. In such cases, they are written in the temporary directory set in
the dask config’s <code class="code docutils literal notranslate"><span class="pre">temporary_directory</span></code> variable. When working on HPC system on Compute Canada,
make sure this path is set to a /scratch directory where number of file allowed to be created is large
enough.</p>
<p>Dask Client setup is described in the <a class="reference external" href="https://distributed.dask.org/en/stable/quickstart.html">Dask quickstart</a>
page. See <a class="reference external" href="https://stackoverflow.com/questions/71470336/using-dask-without-client-client">this SO post</a> to
determine if you need to initialize a client or not. Below examples are modified from the simplest setup
in the quickstart guide.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="kn">import</span> <span class="nn">dask.config</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
    <span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>

    <span class="n">TMP_PATH</span> <span class="o">=</span> <span class="s2">&quot;path/to/tmp/dir&quot;</span>  <span class="c1"># CHANGE THIS TO AN EMPTY PATH YOU WOULD LIKE TO USE FOR CACHING</span>
    <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s1">&#39;temporary_directory&#39;</span><span class="p">:</span> <span class="n">TMP_PATH</span><span class="p">}):</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">((</span><span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>  <span class="c1"># will output 9</span>
</pre></div>
</div>
<p>The line <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code> ensures only the main thread executes the task creation
code. The line of the <code class="code docutils literal notranslate"><span class="pre">Client()</span></code> call spawns worker threads that executes exactly the same script back from
the top. If the guarding statement is not present, the worker re-executes the Client creation code and which
leads to into an infinite loop. However, some complications may stem from this, one of which is described in the
following example: (I encountered this when displaying large multiscale images):</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="kn">import</span> <span class="nn">dask.config</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
    <span class="kn">import</span> <span class="nn">napari</span>
    <span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>

    <span class="n">TMP_PATH</span> <span class="o">=</span> <span class="s2">&quot;path/to/tmp/dir&quot;</span>
    <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s1">&#39;temporary_directory&#39;</span><span class="p">:</span> <span class="n">TMP_PATH</span><span class="p">}):</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">viewer</span> <span class="o">=</span> <span class="n">napari</span><span class="o">.</span><span class="n">Viewer</span><span class="p">(</span><span class="n">ndisplay</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">add_ome_zarr_array_from_path</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># add a large OME ZARR image</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># here all threads available will be used to fetch data to show image</span>
</pre></div>
</div>
<p>Napari utilizes all threads on the current process to load chunks from the image when we drag mouse to navigation
across chunks. With typical dask setup, however, worker threads spawned by the <code class="code docutils literal notranslate"><span class="pre">Client()</span></code> call take up all
threads except one for the main thread. If viewer.show(block=True) is called
on the main thread, then Napari viewer does not get the rest of the threads, and the loading speed is slow
(working but with some lagging). The issue is not in adding the image to the viewer, but in the call to
viewer.show() where the loading happens. I also found that the loading speed is slow regardless if the value
of threads_per_worker is set to 1 or more in the Client() initialization.</p>
<p>My solution: Since a running dask Client object seems to be the cause of the problem, calling client.close()
before viewer.show(block=True) solves the problem:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">viewer</span><span class="o">.</span><span class="n">add_ome_zarr_array_from_path</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># adding image itself does not take too much time</span>
<span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># here resources are freed up</span>
<span class="n">viewer</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># threads are now available to fetch data to show image</span>
</pre></div>
</div>
<p>This does mean any Napari will not use the cluster if images are added as dask arrays, though Dask arrays
are processed multithreaded by default without the need of a cluster.</p>
</section>
<section id="dask-logging-setup">
<h2>Dask Logging Setup<a class="headerlink" href="#dask-logging-setup" title="Permalink to this heading"></a></h2>
<p>Distributed logging setup. Python’s logging module is supported by Dask but I’ve had some issues to get it
right, so I looked and found Dask provides a simple strategy for debug logging as described in <a class="reference external" href="https://docs.dask.org/en/latest/how-to/debug.html">this page</a>. The solution is to use the same logging as usual for
the main threads, and use dask.distributed.print to print debugging messages if inside a worker thread. For
convenience I also echo the stdout and stderr outputs into separate logfiles so they will persist even if you
accidentally close the command window. Below is an example:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cvpl_tools.im.fs</span> <span class="k">as</span> <span class="nn">imfs</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="nb">print</span> <span class="k">as</span> <span class="n">dprint</span>

    <span class="n">logfile_stdout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;log_stdout.txt&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">logfile_stderr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;log_stderr.txt&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">imfs</span><span class="o">.</span><span class="n">MultiOutputStream</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">logfile_stdout</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">imfs</span><span class="o">.</span><span class="n">MultiOutputStream</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">logfile_stderr</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="kn">import</span> <span class="nn">dask.config</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
    <span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>

    <span class="n">TMP_PATH</span> <span class="o">=</span> <span class="s2">&quot;path/to/tmp/dir&quot;</span>
    <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s1">&#39;temporary_directory&#39;</span><span class="p">:</span> <span class="n">TMP_PATH</span><span class="p">}):</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">((</span><span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>  <span class="c1"># will output 9</span>

        <span class="k">def</span> <span class="nf">map_fn</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">dprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;map_fn is called with input </span><span class="si">{</span><span class="n">block</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result is:&#39;</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre></div>
</div>
<p>After running this program, you should see outputs in both the command window and the log_stdout.txt and
log_stderr.txt files under your working directory.</p>
</section>
<section id="cachedirectory">
<h2>CacheDirectory<a class="headerlink" href="#cachedirectory" title="Permalink to this heading"></a></h2>
<p>Different from Dask’s temporary directory, cvpl_tool’s CacheDirectory class provides intermediate result
caching APIs. A multi-step segmentation pipeline may produce many intermediate results, for some of them we
may discard once computed, and for the others (like the final output) we may want to cache them on the disk
for access later without having to redo the computation. In order to cache the result, we need a fixed path
that do not change across program executions. The <code class="code docutils literal notranslate"><span class="pre">CacheDirectory</span></code> class is one that manages and
assigns paths for these intermediate results, based on their cache ID (cid) and the parent CacheDirectory
they belongs to. <code class="code docutils literal notranslate"><span class="pre">CacheRootDirectory</span></code> is a subclass of <code class="code docutils literal notranslate"><span class="pre">CacheDirectory</span></code> that acts as the root
of the cache directory structure.</p>
<p>In cvpl_tool’s model of caching, there is a root cache directory that is created or loaded when the program
starts to run, and every cache directory may contain many sub-cache-directory or data directories in
which there are intermediate files. To create a cache directory, we write</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cvpl_tools.im.fs</span> <span class="k">as</span> <span class="nn">imfs</span>
    <span class="k">with</span> <span class="n">imfs</span><span class="o">.</span><span class="n">CacheRootDirectory</span><span class="p">(</span>
          <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">TMP_PATH</span><span class="si">}</span><span class="s1">/CacheDirectory&#39;</span><span class="p">,</span>
          <span class="n">remove_when_done</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">read_if_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">temp_directory</span><span class="p">):</span>

        <span class="c1"># Use case #1. Create a data directory for caching computation results</span>
        <span class="n">cache_path</span> <span class="o">=</span> <span class="n">temp_directory</span><span class="o">.</span><span class="n">cache_subpath</span><span class="p">(</span><span class="n">cid</span><span class="o">=</span><span class="s1">&#39;some_cache_path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_path</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cache_path</span><span class="o">.</span><span class="n">abs_path</span><span class="p">,</span> <span class="n">exists_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># PUT CODE HERE: Now write your data into cache_path.abs_path and load it back later</span>

        <span class="c1"># Use case #2. Create a sub-directory and pass it to other processes for caching</span>
        <span class="k">def</span> <span class="nf">multi_step_computation</span><span class="p">(</span><span class="n">cache_at</span><span class="p">:</span> <span class="n">imfs</span><span class="o">.</span><span class="n">CacheDirectory</span><span class="p">):</span>
            <span class="n">cache_path</span> <span class="o">=</span> <span class="n">cache_at</span><span class="o">.</span><span class="n">cache_subpath</span><span class="p">(</span><span class="n">cid</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_path</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">computeA</span><span class="p">()</span>
                <span class="n">save</span><span class="p">(</span><span class="n">cache_path</span><span class="o">.</span><span class="n">abs_path</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">cache_path</span><span class="o">.</span><span class="n">abs_path</span><span class="p">)</span>

            <span class="n">cache_path_B</span> <span class="o">=</span> <span class="n">cache_at</span><span class="o">.</span><span class="n">cache_subpath</span><span class="p">(</span><span class="n">cid</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_path_B</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">computeBFromA</span><span class="p">()</span>
                <span class="n">save</span><span class="p">(</span><span class="n">cache_path_B</span><span class="o">.</span><span class="n">abs_path</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">cache_path_B</span><span class="o">.</span><span class="n">abs_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">B</span>

        <span class="n">sub_temp_directory</span> <span class="o">=</span> <span class="n">temp_directory</span><span class="o">.</span><span class="n">cache_subdir</span><span class="p">(</span><span class="n">cid</span><span class="o">=</span><span class="s1">&#39;mult_step_cache&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">multi_step_computation</span><span class="p">(</span><span class="n">cache_at</span><span class="o">=</span><span class="n">sub_temp_directory</span><span class="p">)</span>
</pre></div>
</div>
<p>After running the above code once, caching files will be created. The second time the code is run, the computation
steps will be skipped. This sort of hierarchical caching is convenient for working with complex processes that
can be hierarchically broken down to smaller and simpler compute steps.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ome_zarr.html" class="btn btn-neutral float-left" title="OME_ZARR" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="segmentation_pipeline.html" class="btn btn-neutral float-right" title="Segmentation Pipeline" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, KarlHanUW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>