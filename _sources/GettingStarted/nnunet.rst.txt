.. _nnunet:

nn-UNet
#######

Overview
********

nn-UNet is a UNet based library designed to segment medical images, refer to
`github <https://github.com/MIC-DKFZ/nnUNet>`_ and the following citation:

- Isensee, F., Jaeger, P. F., Kohl, S. A., Petersen, J., & Maier-Hein, K. H. (2021). nnU-Net: a self-configuring
  method for deep learning-based biomedical image segmentation. Nature methods, 18(2), 203-211.

nn-UNet is easiest to use with their command line interface with three commands :code:`nnUNetv2_plan_and_preprocess`,
:code:`nnUNetv2_train` and :code:`nnUNetv2_predict`.

For :code:`cvpl_tools`, :code:`cvpl_tools/nnunet/cli.py` provides two
wrapper command line interface commands :code:`train` and :code:`predict` that simplify the three commands into
two and hides unused parameters for SPIMquant workflow.

:code:`cvpl_tools/nnunet` needs torch library and :code:`pip install nnunetv2`. GPU is automatically used when
:code:`nnUNetv2_train` and :code:`nnUNetv2_predict` are called directly or indirectly through :code:`train` and
:code:`predict` and when you have a GPU available on the computer.

For those unfamiliar, nn-UNet has the following quirks:

- Residual encoder is available for nnunetv2 but we prefer without it since it costs more to train

- Due to limited training data, 2d instead of 3d_fullres mode is used in :code:`cvpl_tools`

- It trains on images pairs of input size (C, Y, X) and output size (Y, X) where C is number of color channels
  (1 in our case), and Y, X are spatial coordinates; specifically, N pairs of images will be provided as training
  set and a 80%-20% split will be done for train-validation split which is automatically done by nnUNet. It should
  be noted in our case we draw Z images from a single scan volume (C, Z, Y, X), so a random split will have
  training set distribution correlated with validation set generated by nnUNet, but such thing is hard to avoid

- The algorithm is not scale-invariant, meaning during prediction, if we zoom the input image by a factor of 2x or
  0.5x we get much worse output results. For best results, use the same input/output image sizes as the training
  phase. In our mousebrain lightsheet dataset, we downsample the original >200GB dataset by a factor of (4, 8, 8)
  before running the nnUNet for training or prediction.

- The algorithm supports the following epochs, useful for small-scale training in our case:
  `link <https://github.com/MIC-DKFZ/nnUNet/blob/master/nnunetv2/training/nnUNetTrainer/variants/training_length/nnUNetTrainer_Xepochs.py>`_
  if you input number of epochs not listed in this page to the :code:`predict` command, an error will occur

- nn-UNet supports 5-fold ensemble, which is to run :code:`nnUNetv2_train` command 5 times each on a different
  80%-20% split to obtain 5 models to ensemble the prediction. This does not require rerun :code:`nnUNetv2_plan_and_preprocess`
  and is supported by the :code:`--fold` argument of :code:`cvpl_tools`' :code:`train` command so
  you don't need to run it 5 times. If you finish training all folds, you may use the :code:`--fold` argument of
  :code:`cvpl_tools`' :code:`predict` command to specify :code:`all` for better accuracy after ensemble or
  :code:`0` to specify using the first fold trained for comparison.

- Running the nn-UNet's command :code:`nnUNetv2_train` or :code:`cvpl_tools`' :code:`train` generates one
  :code:`nnUNet_results` folder, which contains a model (of size a few hundred MBs) and a folder of results
  including a loss/DICE graph and a log file containing training losses per epoch and per class. The
  same model file is used later for prediction.


Negative Masking for Mouse-brain Lightsheet
*******************************************

In this section, we focus primarily on the usage of nn-UNet within :code:`cvpl_tools`. This part of the
library is designed with handling mouse-brain lightsheet scans in mind. These scans are large (>200GB)
volumes of scans in the format of 4d arrays of data type np.uint16 which is of shape (C, Z, Y, X). An
example is in the google storage bucket
"gcs://khanlab-lightsheet/data/mouse_appmaptapoe/bids/sub-F4A1Te3/micr/sub-F4A1Te3_sample-brain_acq-blaze4x_SPIM.ome.zarr"
with an image shape of (3, 1610, 9653, 9634).

The objective of our algorithm is to quantify the locations and sizes of beta-amyloid plaques in a volume
of lightsheet scan like the above, which appear as small-sized round-shaped bright spots in the image
volume, and can be detected using a simple thresholding method.

Problem comes, however, since the scanned mouse brain edges areas are as bright as the plaques, they
will be marked as false positives. These edges are relatively easier to detect by a UNet algorithm, which
results in the following segmentation workflow we use:

1. For N mousebrain scans M1, ..., MN we have at hand, apply bias correction to smooth out within image brightness
   difference caused by imaging artifacts

2. Then select one of N scans, say M1

2. Downsample M1 and use a GUI to paint a binary mask, which contains 1 on regions of edges and 0 on plaques and
   elsewhere

3. Split the M1 volume and its binary mask annotation vertically to Z slices, and train an nnUNet model on these slices

4. Above produces a model that can predict negative masks on any mousebrain scans of the same format; for the rest N-1
   mouse brains, they are down-sampled and we use this model to predict on them to obtain their corresponding negative
   masks

5. These masks are used to remove edge areas of the image before we apply thresholding to find plaque objects.
   Algorithmically, we compute M' where :code:`M'[z, y, x] = M[z, y, x] * (1 - NEG_MASK[z, y, x]`) for each
   voxel location (z, y, x); then, we apply threshold on M' and take connected component of value of 1 as individual
   plaque objects; their centroid locations and sizes (in number of voxels) are summarized in a numpy table and
   reported

In this next part, we discuss the annotation (part 2), training (part 3) and prediction (part 4).

Annotation
**********

Data quality is the most crucial to accurate predictions, in which case this is relevant to us in terms of how
well we can annotate the 3d image volume at hand. Our annotation is the negative masking of edge areas of the
brain to remove edges before applying simple thresholding. We model how good an annotation of negative mask by
looking at:

1. For the simple threshold of choice t, how many voxels are above the threshold across the entire image,
   say V

2. The number of voxels covered by plaques areas above threshold t, and how many of them are correctly annotated
   as 0, and how many of them are incorrectly annotated as 1

3. The number of voxels covered by brain edge areas above threshold t, and how many of them are correctly annotated
   as 1, and how many of them are incorrectly annotated as 0

these metrics are best summarized as IOU or DICE scores. We look at an example segmentation below.

.. figure:: ../assets/mb_unmasked.png
    :alt: Slice of mouse brain, unsegmented

    Slice of the mouse brain, not annotated (without negative masking)

.. figure:: ../assets/mb_masked.png
    :alt: Slice of mouse brain, negative masked

    Slice of the mouse brain, annotated (with negative masking)

Here the algorithm, as intended, marks not only the outer edges of the brain but also some of the brighter inner
structures as edge areas to be removed, since they can't be plaques. The bright spots on the upper left of the images
are left as is, for they are all plaques. Overall, the annotation requires quite a bit of labour and it is preferred
to obtain a high quality annotated volume over many low quality ones.