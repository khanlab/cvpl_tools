.. _result_caching:

Result Caching
##############

Overview
********
In many cases it's useful to cache some of the intermediate results instead of discarding all the computation results
all at once. Think of the following cases where you may have encountered when writing a long-running image processing
workflow:

1. The cell density for each region in the scan is computed but the number does not match up with what's expected,
so you want to display a heatmap in a graphical viewer showing cell density. The final results you got is text
output in the console, requiring redoing the computation to display.

2. Some error occurs and you need to find out why a step in the computation causes the issue, but it's rather
difficult to understand what went wrong without displaying some intermediate results to aid debugging.

3. Graphically showing how the algorithm works step-by-step will be very help in identifying causes of
issues, but requires saving all the results onto disk and chunked in a viewer-friendly format.

In all cases above, caching all the intermediate results help reduce headaches and risks of unknown errors coming
from the difficulty of debugging in an image processing and distributed computing environment. The basic strategy
we use to overcome these is to cache all the results inside a directory tree. Each step saves all its
intermediate and final results onto a node in the tree. The node's children are directories saved by its
sub-steps.

Here, the outputs of a processing step (function) may contain intermediate images (such as .ome.zarr), log files
(.txt) and graphs generated by plotting libraries.

We describe the CacheDirectory interface in details below.

cache root directory
********************
Every cache directory tree starts with a CacheRootDirectory node at its root, which is the only node of that class in
the tree. In order to create a cache directory tree you need a url to the root directory location, as follows:

.. code-block:: Python

    import cvpl_tools.tools.fs as tlfs
    loc = f'path/to/root'  # a remote url will work as well
    query = tlfs.cdir_init(loc)
    # Now a directory is created at the given path, so you can start writing cache files to it

This creates two directories 'path/to/root' on the first run,
the naming of the subfolder indicates that it is :code:`dir` a directory and :code:`cache` a
persistent cache instead of a temporary folder in that location.
The next time the program is run, it will not create new folders but return a query object with
:code:`query.commit=True`

cache directory
***************
A cache directory can be a child directory of a cache root directory or other cache directories.

.. code-block:: Python

    import cvpl_tools.tools.fs as tlfs
    loc = f'path/to/root'  # a remote url will work as well
    query = tlfs.cdir_init(loc)
    if not query.commit:  # if this is first time, compute the result instead of read from saved result
        sub_query = tlfs.cdir_init(f'{loc}/subdir')
        if query.commit:
            print('subdirectory is already created')
        else:
            print('subdirectory created successfully')

Tips
****
- when writing a process function that cache to a single location, receive a cache_url object as a keyed
  item :code:`context_args["cache_url"]` which can be None if we don't want to write to disk
- Dask duplicates some computation twice because it does not support on-disk caching directly, using cache
  files in each step can avoid this issue and help speedup computation.
- cache the images in a viewer-readable format. For OME-ZARR a flat image chunking scheme is
  suitable for 2D viewers like Napari. Re-chunking when loading back to memory may be slower but is usually
  not a big issue.
